import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { URLS } from '../../constants/urls';
import axios, { AxiosError } from 'axios';

// createAsyncThunk is used for asynchronous actions.
// It will automatically dispatch pending, fulfilled, and rejected actions.
export const fetchDataScan = createAsyncThunk(
  'dataScan/fetchDataScan', 
  async (requestData: any, { rejectWithValue, getState }) => {
    if (!requestData) {
      return { name: '', data: null };
    }

    // Check if we already have this specific scan data and it's not stale
    const state = getState() as any;
    const existingData = state.dataScan.scans[requestData.name];
    const lastFetched = existingData?.lastFetched;
    const currentTime = Date.now();
    
    // If we have data and it's less than 5 minutes old, return existing data
    if (existingData && existingData.data && 
        lastFetched && (currentTime - lastFetched) < 5 * 60 * 1000) {
      return { name: requestData.name, data: existingData.data };
    }

    try {
      // search from your API endpoint 
      axios.defaults.headers.common['Authorization'] = requestData.id_token ? `Bearer ${requestData.id_token}` : '';
      let name = requestData.name;
      
      const response = await axios.get(URLS.API_URL + URLS.GET_DATA_SCAN + `?name=${name}`);
      const data = await response.data;
      return { name: requestData.name, data: data };

    } catch (error) {
      if (error instanceof AxiosError) {
        return rejectWithValue(error.response?.data || error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  },
  {
    // Add condition to prevent duplicate requests for the same scan
    condition: (requestData, { getState }) => {
      if (!requestData) return false;
      
      const state = getState() as any;
      const isCurrentlyLoading = state.dataScan.loadingScans.includes(requestData.name);
      const existingData = state.dataScan.scans[requestData.name];
      
      // If we're already loading this specific scan or have recent data, don't make another request
      if (isCurrentlyLoading || (existingData && existingData.data)) {
        return false;
      }
      return true;
    }
  }
);

export const fetchAllDataScans = createAsyncThunk(
  'dataScan/fetchAllDataScans',
  async (requestData: { id_token: string, projectId: string }, { rejectWithValue }) => {
    try {
      axios.defaults.headers.common['Authorization'] = `Bearer ${requestData.id_token}`;
      const response = await axios.get(URLS.API_URL + URLS.GET_ALL_DATA_SCANS+`?project=${requestData.projectId}`);
      const data = await response.data;
      return data;
    } catch (error) {
      if (error instanceof AxiosError) {
        return rejectWithValue(error.response?.data || error.message);
      }
      return rejectWithValue('An unknown error occurred');
    }
  }
);

type ScanData = {
  data: any;
  lastFetched: number;
  status: 'idle' | 'loading' | 'succeeded' | 'failed';
  error: string | null;
};

type DataScanState = {
  scans: { [scanName: string]: ScanData };
  loadingScans: string[];
  globalStatus: 'idle' | 'loading' | 'succeeded' | 'failed';
  allScans: any[];
  allScansStatus: 'idle' | 'loading' | 'succeeded' | 'failed';
};

const initialState: DataScanState = {
  scans: {},
  loadingScans: [],
  globalStatus: 'idle',
  allScans: [],
  allScansStatus: 'idle',
};

// createSlice generates actions and reducers for a slice of the Redux state.
export const dataScanSlice = createSlice({
  name: 'dataScan',
  initialState,
  reducers: {
    // Add a reducer to clear specific scan data
    clearScanData: (state, action) => {
      const scanName = action.payload;
      delete state.scans[scanName];
      state.loadingScans = state.loadingScans.filter(name => name !== scanName);
    },
    // Add a reducer to clear all scan data
    clearAllScanData: (state) => {
      state.scans = {};
      state.loadingScans = [];
      state.globalStatus = 'idle';
    },
    // Add a reducer to update last fetched time for a specific scan
    updateScanLastFetched: (state, action) => {
      const { scanName, timestamp } = action.payload;
      if (state.scans[scanName]) {
        state.scans[scanName].lastFetched = timestamp;
      }
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk.
  extraReducers: (builder) => {
    builder
      .addCase(fetchDataScan.pending, (state, action) => {
        const scanName = action.meta.arg.name;
        // Initialize scan data if it doesn't exist
        if (!state.scans[scanName]) {
          state.scans[scanName] = {
            data: null,
            lastFetched: 0,
            status: 'loading',
            error: null
          };
        } else {
          state.scans[scanName].status = 'loading';
          state.scans[scanName].error = null;
        }
        
        // Add to loading scans if not already there
        if (!state.loadingScans.includes(scanName)) {
          state.loadingScans.push(scanName);
        }
        
        // Update global status
        if (state.globalStatus === 'idle') {
          state.globalStatus = 'loading';
        }
      })
      .addCase(fetchDataScan.fulfilled, (state, action) => {
        const scanName = action.payload.name;
        const scanData = action.payload.data;
        
        if (state.scans[scanName]) {
          state.scans[scanName].status = 'succeeded';
          state.scans[scanName].data = scanData;
          state.scans[scanName].lastFetched = Date.now();
          state.scans[scanName].error = null;
        }
        
        // Remove from loading scans
        state.loadingScans = state.loadingScans.filter(name => name !== scanName);
        
        // Update global status
        if (state.loadingScans.length === 0) {
          state.globalStatus = 'succeeded';
        }
      })
      .addCase(fetchDataScan.rejected, (state, action) => {
        const scanName = action.meta.arg.name;
        
        if (state.scans[scanName]) {
          state.scans[scanName].status = 'failed';
          state.scans[scanName].error = action.error.message || 'Unknown error';
        }
        
        // Remove from loading scans
        state.loadingScans = state.loadingScans.filter(name => name !== scanName);
        
        // Update global status
        if (state.loadingScans.length === 0) {
          state.globalStatus = 'failed';
        }
      })
      .addCase(fetchAllDataScans.pending, (state) => {
        state.allScansStatus = 'loading';
      })
      .addCase(fetchAllDataScans.fulfilled, (state, action) => {
        state.allScansStatus = 'succeeded';
        console.log('allScans: ', action.payload);
        state.allScans = action.payload || [];
      })
      .addCase(fetchAllDataScans.rejected, (state, action) => {
        state.allScansStatus = 'failed';
        // You might want to log the error: state.error = action.payload;
        console.log('dataScan payload: ', action.payload);
      });
  },
});

// Selectors for easier access to specific scan data
export const selectScanData = (scanName: string) => (state: any) => state.dataScan.scans[scanName]?.data;
export const selectScanStatus = (scanName: string) => (state: any) => state.dataScan.scans[scanName]?.status || 'idle';
export const selectScanError = (scanName: string) => (state: any) => state.dataScan.scans[scanName]?.error;
export const selectIsScanLoading = (scanName: string) => (state: any) => state.dataScan.loadingScans.includes(scanName);
export const selectAllScans = (state: any) => state.dataScan.allScans;
export const selectAllScansStatus = (state: any) => state.dataScan.allScansStatus;


export const { clearScanData, clearAllScanData, updateScanLastFetched } = dataScanSlice.actions;
export default dataScanSlice.reducer;
